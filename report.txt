Annu Yadav 2020CS10325 && Deepak Singh 2020CS50422 

Algorithm Description:
Algorithm Overview:  The algorithm is designed to correct automatic speech recognition (ASR) errors by iteratively generating and evaluating candidate word replacements based on a phoneme table. The approach integrates elements of both local search and iterative deepening, with the goal of finding the best possible correction by exploring possible alternatives at varying levels of depth.
Candidate Generation:  
The generate_candidates function generates candidate words by replacing up to a specified number of characters (depth) in the original word. The replacements are determined using the phoneme table, which lists possible phonetic substitutions for each character. The candidates are generated by considering all combinations of up to depth characters in the word and replacing them with alternatives from the phoneme table.
State Evaluation:  The evaluate_state function calculates the cost of a given state (a candidate sentence) using a cost function provided by the environment. This cost function evaluates how well a candidate state matches the desired output, with a lower cost indicating a better match.
ASR Correction:  
The main function, asr_corrector, initializes the search with the original ASR output as the best state. The algorithm then iteratively deepens the search by increasing the depth of character replacements. At each depth level, the algorithm evaluates all possible candidates generated by the generate_candidates function for each word in the sentence. The candidate that yields the lowest cost is selected as the new best state. This process continues until no further improvement is found or the maximum depth is reached.
Objective Function:
The cost function used in the environment serves as the objective function. The goal is to minimize this cost by iteratively refining the candidate sentence. The function considers the context of the word being corrected, taking into account the two preceding and two following words to ensure that corrections make sense in the broader context of the sentence.
Local Search:
The algorithm employs a greedy local search strategy, where at each step, the best candidate (i.e., the one with the lowest cost) is chosen. The search is localized to individual words and their immediate context, ensuring that corrections are contextually appropriate.
Iterative Deepening:
The search process is akin to iterative deepening in that the depth of character replacements is gradually increased. Initially, only single-character changes are considered (depth = 1), and as the algorithm progresses, more complex changes involving multiple characters (up to the maximum depth) are explored. This allows the algorithm to start with simple corrections and progressively handle more complicated errors.
Dynamic Programming:
While the algorithm does not explicitly use dynamic programming, the iterative approach ensures that the search builds on previous results. At each step, the best state found so far is refined further, reducing the overall search space and making the process more efficient.
Heuristic:
The heuristic is implicitly defined by the cost function, which guides the search towards states that are more likely to be correct. The algorithm does not employ a separate heuristic function but relies on the cost function to evaluate the quality of each candidate state.
Transition Cost:
The transition cost is not explicitly calculated in this algorithm. Instead, the cost associated with each candidate state (as determined by the cost function) indirectly reflects the transition cost, as it incorporates the context and the number of character changes.
Branching Factor:
The branching factor is determined by the phoneme table and the depth of the search. At each depth level, the number of possible candidates increases, with more character combinations being considered. The effective branching
factor depends on the number of phonetic alternatives available for each character and the length of the word being corrected.
